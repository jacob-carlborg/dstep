/**
 * Copyright: Copyright (c) 2016 Jacob Carlborg. All rights reserved.
 * Authors: Jacob Carlborg
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0)
 */
module dstep.Configuration;

import clang.Util;

import dstep.translator.Options;

/**
 *  Aggregation of global configuration options affecting the program
 */
struct Configuration
{
    /// app version string, generated by the build system
    enum Version = import("VERSION")[1 .. $]; // strip the leading 'v'

    /// array of file names to translate to D
    string[] inputFiles;

    /// expected programming language of input files
    Language language;

    /// show dstep version
    @("version", "Show dstep version.")
    bool dstepVersion;

    /// show libclang version
    @("clang-version", "Show libclang version.")
    bool clangVersion;

    /// array of parameters needed to be forwarded to clang driver
    string[] clangParams;

    /// output file name or folder
    string outputPath;

    /// in case there are many input files or dir output option provided
    bool isOutputToDir;

    /// package name
    @("package", "Use <package> as package name.")
    string packageName;

    /// enable translation of comments
    @("comments", "Translate comments [default].")
    bool enableComments = true;

    /// use public imports for submodules
    @("public-submodules", "Use public imports for submodules [default].")
    bool publicSubmodules = false;

    // rename modules to D conforming form
    @("normalize-modules", "Rename modules to D conforming form [default].")
    bool normalizeModules = false;

    /// enable reduction of primitive type aliases
    @("reduce-aliases", "Reduce primitive type aliases [default].")
    bool reduceAliases = true;

    /// translate C preprocessor macros if possible
    @("translate-macros", "Translate C preprocessor macros if possible [default].")
    bool translateMacros = true;

    /// generate aliases for enum members in global scope
    @("alias-enum-members", "Generate aliases for enum members in global scope [default].")
    bool aliasEnumMembers = false;

    /// attempt to rename the enumeration members to D conforming form
    @("rename-enum-members", "Attempt to rename the enumeration members to D conforming form. [default].")
    bool renameEnumMembers = false;

    /// translate to wchar_t to core.stdc.stddef.wchar_t
    @("portable-wchar_t", "Translate wchar_t as core.stdc.stddef.wchar_t [default].")
    bool portableWCharT = true;

    /// translate functions with empty argument list as vararg
    @("zero-param-is-vararg", "Translate functions with no arguments as variadic functions [default].")
    bool zeroParamIsVararg = false;

    /// single line function headers
    @("single-line-function-signatures", "Keep function signatures in a single line [default].")
    bool singleLineFunctionSignatures = false;

    /// space after function name
    @("space-after-function-name", "Put a space after a function name [default].")
    bool spaceAfterFunctionName = true;

    /// do not translate bodies of following structs and unions
    @("skip-definition", "Keep only the signature of <symbol>.")
    string[] skipDefinitions;

    /// do not translate following symbols
    @("skip", "Skip translation of <symbol>.")
    string[] skipSymbols;

    /// print diagnostic informations
    @("print-diagnostics", "Print diagnostic informations [default].")
    bool printDiagnostics = true;

    /// action to take on symbol collision
    @("collision-action", "Action to take when translated symbol collides with a preexisting symbol [default].")
    CollisionAction collisionAction = CollisionAction.rename;

    /// add global attributes
    @("global-attribute", "Add <attribute> as a global attribute.")
    string[] globalAttributes;

    /// add global imports
    @("global-import", "Add <import> as a global import.")
    string[] globalImports;

    Options toOptions(string inputFile, string outputFile) const
    {
        Options options = toOptions();

        options.inputFile = inputFile.asAbsNormPath;
        options.outputFile = outputFile.asAbsNormPath;

        return options;
    }

    Options toOptions() const
    {
        import std.algorithm.iteration : map;
        import std.array;

        Options options;
        options.inputFiles = inputFiles.map!(path => path.asAbsNormPath).array;
        options.language = language;
        options.enableComments = enableComments;
        options.packageName = packageName;
        options.publicSubmodules = publicSubmodules;
        options.normalizeModules = normalizeModules;
        options.reduceAliases = reduceAliases;
        options.translateMacros = translateMacros;
        options.aliasEnumMembers = aliasEnumMembers;
        options.renameEnumMembers = renameEnumMembers;
        options.portableWCharT = portableWCharT;
        options.zeroParamIsVararg = zeroParamIsVararg;
        options.singleLineFunctionSignatures = singleLineFunctionSignatures;
        options.spaceAfterFunctionName = spaceAfterFunctionName;
        options.skipDefinitions = setFromList(skipDefinitions);
        options.skipSymbols = setFromList(skipSymbols);
        options.printDiagnostics = printDiagnostics;
        options.collisionAction = collisionAction;
        options.globalAttributes = globalAttributes;
        options.globalImports = globalImports;

        return options;
    }
}

template makeGetOptArgs(alias config)
{
    import std.meta;

    template expand(alias spelling)
    {
        alias member = Alias!(__traits(getMember, config, spelling));

        static if (
            __traits(compiles, &__traits(getMember, config, spelling)) &&
            __traits(getAttributes, member).length == 2)
        {
            auto ptr() @property
            {
                return &__traits(getMember, config, spelling);
            }

            auto formatHelp(alias spelling)(string help)
            {
                import std.algorithm;
                import std.format;
                import std.string;
                import std.range;

                Configuration config;

                string suffix;

                static if (is(typeof(member) == bool) || is(typeof(member) == enum))
                {
                    auto default_ = "[default]";

                    if (help.canFind(default_))
                    {
                        help = help.replace(
                            default_,
                            format("[default: %s]", __traits(getMember, config, spelling)));

                        static if (is(typeof(member) == bool))
                        {
                            suffix = "=true|false";
                        }
                        else
                        {
                            suffix = format(
                                "=%s",
                                join([ __traits(allMembers, typeof(member)) ], "|"));
                        }
                    }
                }
                else
                {
                    auto beginning = findSplitBefore(help, "<");

                    if (!beginning[0].empty)
                    {
                        auto placeholder = findSplitAfter(beginning[1], ">");

                        if (!placeholder[0].empty)
                            suffix = format(" %s", placeholder[0]);
                    }
                }

                return format("%s!%s", suffix, help);
            }

            alias expand = AliasSeq!(
                __traits(getAttributes, __traits(getMember, config, spelling))[0],
                formatHelp!spelling(
                    __traits(getAttributes, __traits(getMember, config, spelling))[1]),
                ptr);
        }
        else
        {
            alias expand = AliasSeq!();
        }
    }

    alias makeGetOptArgs = staticMap!(expand, __traits(allMembers, typeof(config)));
}

