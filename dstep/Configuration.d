/**
 * Copyright: Copyright (c) 2016 Jacob Carlborg. All rights reserved.
 * Authors: Jacob Carlborg
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0)
 */
module dstep.Configuration;

import clang.Util;

import dstep.translator.Options;

/**
 *  Aggregation of global configuration options affecting the program
 */
struct Configuration
{
    /// app version string, generated by the build system
    enum Version = import("VERSION");

    /// array of file names to translate to D
    string[] inputFiles;

    /// expected programming language of input files
    @("language|x", "Treat subsequent input files as having type <language>.")
    Language language;

    /// show dstep version
    @("version", "Show dstep version.")
    bool dstepVersion;

    /// show libclang version
    @("clang-version", "Show libclang version.")
    bool clangVersion;

    /// array of parameters needed to be forwarded to clang driver
    string[] clangParams;

    /// output file name or folder (in case there are many input files)
    string output;

    /// package name
    @("package", "Use <package> as package name.")
    string packageName;

    /// enable translation of comments
    @("comments", "Translate comments [default].")
    bool enableComments = true;

    /// use public imports for submodules
    @("public-submodules", "Use public imports for submodules [default].")
    bool publicSubmodules = false;

    /// enable reduction of primitive type aliases
    @("reduce-aliases", "Reduce primitive type aliases [default].")
    bool reduceAliases = true;

    /// translate to wchar_t to core.stdc.stddef.wchar_t
    @("portable-wchar_t", "Translate wchar_t as core.stdc.stddef.wchar_t [default].")
    bool portableWCharT = true;

    /// translate functions with empty argument list as vararg
    @("zero-param-is-vararg", "Translate functions with no arguments as variadic functions [default].")
    bool zeroParamIsVararg = false;

    /// single line function headers
    @("single-line-function-signatures", "Keep function signatures in a single line [default].")
    bool singleLineFunctionSignatures = false;

    /// space after function name
    @("space-after-function-name", "Put a space after a function name [default].")
    bool spaceAfterFunctionName = true;

    /// do not translate bodies of following structs and unions
    @("skip-definition", "Keep only the signature of <symbol>.")
    string[] skipDefinitions;

    /// do not translate following symbols
    @("skip", "Skip translation of <symbol>.")
    string[] skipSymbols;
}

template makeGetOptArgs(alias config)
{
    import std.meta;

    template expand(alias spelling)
    {
        static if (
            __traits(compiles, &__traits(getMember, config, spelling)) &&
            __traits(getAttributes, __traits(getMember, config, spelling)).length == 2)
        {
            auto ptr() @property
            {
                return &__traits(getMember, config, spelling);
            }

            auto formatHelp(alias spelling)(string help)
            {
                import std.algorithm : canFind;
                import std.format : format;
                import std.string : replace;


                Configuration config;

                static if (is(typeof(__traits(getMember, config, spelling)) == bool))
                {
                    auto default_ = "[default]";

                    if (help.canFind(default_))
                        return help.replace(
                            default_,
                            format("[default: %s]", __traits(getMember, config, spelling)));
                    else
                        return help;
                }
                else
                {
                    return help;
                }
            }

            alias expand = AliasSeq!(
                __traits(getAttributes, __traits(getMember, config, spelling))[0],
                formatHelp!spelling(
                    __traits(getAttributes, __traits(getMember, config, spelling))[1]),
                ptr);
        }
        else
        {
            alias expand = AliasSeq!();
        }
    }

    alias makeGetOptArgs = staticMap!(expand, __traits(allMembers, typeof(config)));
}

